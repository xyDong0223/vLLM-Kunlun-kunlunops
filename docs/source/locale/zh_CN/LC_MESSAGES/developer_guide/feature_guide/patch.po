# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, vllm-kunlun team
# This file is distributed under the same license as the vllm-kunlun
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  vllm-kunlun\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-10 16:59+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/developer_guide/feature_guide/patch.md:1
#, fuzzy
msgid "Patch in vLLM"
msgstr "在 vLLM Kunlun 中的补丁"

#~ msgid ""
#~ "vLLM Kunlun is a platform plugin "
#~ "for vLLM. Due to the release cycle"
#~ " of vLLM and vLLM Kunlun is "
#~ "different, and the hardware limitation "
#~ "in some case, we need to patch "
#~ "some code in vLLM to make it "
#~ "compatible with vLLM Kunlun."
#~ msgstr ""
#~ "vLLM Kunlun 是 vLLM 的一个平台插件。由于 vLLM "
#~ "和 vLLM Kunlun 的发布周期不同，并且在某些情况下存在硬件限制，我们需要对 "
#~ "vLLM 进行一些代码补丁，以使其能够兼容 vLLM Kunlun。"

#~ msgid ""
#~ "In vLLM Kunlun code, we provide a"
#~ " patch module `vllm_kunlun/patch` to "
#~ "address the change for vLLM."
#~ msgstr "在 vLLM Kunlun 代码中，我们提供了一个补丁模块 `vllm_kunlun/patch` 用于应对 vLLM 的变更。"

#~ msgid "Principle"
#~ msgstr "原理"

#~ msgid ""
#~ "We should keep in mind that Patch"
#~ " is not the best way to make"
#~ " vLLM Kunlun compatible. It's just a"
#~ " temporary solution. The best way is"
#~ " to contribute the change to vLLM "
#~ "to make it compatible with vLLM "
#~ "Kunlun originally. In vLLM Kunlun, we"
#~ " have the basic principle for Patch"
#~ " strategy:"
#~ msgstr ""
#~ "我们需要记住，Patch 不是让 vLLM 兼容 Kunlun "
#~ "的最佳方式，这只是一个临时的解决方案。最好的方法是将修改贡献到 vLLM 项目中，从而让 vLLM"
#~ " 原生支持 Kunlun。对于 vLLM Kunlun，我们对 Patch "
#~ "策略有一个基本原则："

#~ msgid "Less is more. Please do not patch unless it's the only way currently."
#~ msgstr "少即是多。请不要打补丁，除非这是目前唯一的方法。"

#~ msgid ""
#~ "Once a patch is added, it's "
#~ "required to describe the future plan "
#~ "for removing the patch."
#~ msgstr "一旦补丁被添加，必须说明将来移除该补丁的计划。"

#~ msgid "Anytime, clean the patch code is welcome."
#~ msgstr "任何时候，欢迎清理补丁代码。"

#~ msgid "How it works"
#~ msgstr "工作原理"

#~ msgid "In `vllm_kunlun/patch`, you can see the code structure as follows:"
#~ msgstr "在 `vllm_kunlun/patch` 目录中，你可以看到如下代码结构："

#~ msgid ""
#~ "**platform**: The patch code in this "
#~ "directory is for patching the code "
#~ "in vLLM main process. It's called "
#~ "by `vllm_kunlun/platform::XPUPlatform::pre_register_and_update`"
#~ " very early when vLLM is initialized."
#~ msgstr ""
#~ "**platform**：此目录下的补丁代码用于修补 vLLM 主进程中的代码。当 vLLM "
#~ "初始化时，会在很早的阶段由 "
#~ "`vllm_kunlun/platform::XPUPlatform::pre_register_and_update` 调用。"

#~ msgid ""
#~ "For online mode, vLLM process calls "
#~ "the platform patch here "
#~ "`vllm/vllm/engine/arg_utils.py::AsyncEngineArgs.add_cli_args` "
#~ "when parsing the cli args."
#~ msgstr ""
#~ "对于在线模式，vLLM 进程在解析命令行参数时，会在 "
#~ "`vllm/vllm/engine/arg_utils.py::AsyncEngineArgs.add_cli_args` "
#~ "这里调用平台补丁。"

#~ msgid ""
#~ "For offline mode, vLLM process calls "
#~ "the platform patch here "
#~ "`vllm/vllm/engine/arg_utils.py::EngineArgs.create_engine_config` "
#~ "when parsing the input parameters."
#~ msgstr ""
#~ "对于离线模式，vLLM 进程在解析输入参数时，会在此处调用平台补丁 "
#~ "`vllm/vllm/engine/arg_utils.py::EngineArgs.create_engine_config`。"

#~ msgid ""
#~ "**worker**: The patch code in this "
#~ "directory is for patching the code "
#~ "in vLLM worker process. It's called "
#~ "by `vllm_kunlun/worker/worker_v1::XPUWorker::__init__` "
#~ "when the vLLM worker process is "
#~ "initialized."
#~ msgstr ""
#~ "**worker**：此目录中的补丁代码用于修补 vLLM worker 进程中的代码。在初始化 "
#~ "vLLM worker 进程时，会被 "
#~ "`vllm_kunlun/worker/worker_v1::XPUWorker::__init__` 调用。"

#~ msgid ""
#~ "For both online and offline mode, "
#~ "vLLM engine core process calls the "
#~ "worker patch here "
#~ "`vllm/vllm/worker/worker_base.py::WorkerWrapperBase.init_worker` "
#~ "when initializing the worker process."
#~ msgstr ""
#~ "无论是在线还是离线模式，vLLM 引擎核心进程在初始化 worker 进程时，都会在这里调用 "
#~ "worker "
#~ "补丁：`vllm/vllm/worker/worker_base.py::WorkerWrapperBase.init_worker`。"

#~ msgid ""
#~ "In both **platform** and **worker** "
#~ "folder, there are several patch modules."
#~ " They are used for patching different"
#~ " version of vLLM."
#~ msgstr "在 **platform** 和 **worker** 文件夹中都有一些补丁模块。它们用于修补不同版本的 vLLM。"

#~ msgid ""
#~ "`patch_0_9_2`: This module is used for"
#~ " patching vLLM 0.9.2. The version is"
#~ " always the nearest version of vLLM."
#~ " Once vLLM is released, we will "
#~ "drop this patch module and bump to"
#~ " a new version. For example, "
#~ "`patch_0_9_2` is used for patching vLLM"
#~ " 0.9.2."
#~ msgstr ""
#~ "`patch_0_9_2`：此模块用于修补 vLLM 0.9.2。该版本始终对应于 vLLM "
#~ "的最近版本。一旦 vLLM 发布新版本，我们将移除此补丁模块并升级到新版本。例如，`patch_0_9_2` "
#~ "就是用于修补 vLLM 0.9.2 的。"

#~ msgid ""
#~ "`patch_main`: This module is used for"
#~ " patching the code in vLLM main "
#~ "branch."
#~ msgstr "`patch_main`：该模块用于修补 vLLM 主分支代码。"

#~ msgid ""
#~ "`patch_common`: This module is used for"
#~ " patching both vLLM 0.9.2 and vLLM"
#~ " main branch."
#~ msgstr "`patch_common`：此模块用于同时修补 vLLM 0.9.2 版本和 vLLM 主分支。"

#~ msgid "How to write a patch"
#~ msgstr "如何撰写补丁"

#~ msgid ""
#~ "Before writing a patch, following the"
#~ " principle above, we should patch the"
#~ " least code. If it's necessary, we"
#~ " can patch the code in either "
#~ "**platform** and **worker** folder. Here "
#~ "is an example to patch `distributed` "
#~ "module in vLLM."
#~ msgstr ""
#~ "在编写补丁之前，遵循上述原则，我们应尽量修改最少的代码。如果有必要，我们可以修改 **platform** 和"
#~ " **worker** 文件夹中的代码。下面是一个在 vLLM 中修改 "
#~ "`distributed` 模块的示例。"

#~ msgid ""
#~ "Decide which version of vLLM we "
#~ "should patch. For example, after "
#~ "analysis, here we want to patch "
#~ "both 0.9.2 and main of vLLM."
#~ msgstr "决定我们应该修补哪个版本的 vLLM。例如，经过分析后，这里我们想要同时修补 vLLM 的 0.9.2 版和主分支（main）。"

#~ msgid ""
#~ "Decide which process we should patch."
#~ " For example, here `distributed` belongs"
#~ " to the vLLM main process, so "
#~ "we should patch `platform`."
#~ msgstr "决定我们应该修补哪个进程。例如，这里 `distributed` 属于 vLLM 主进程，所以我们应该修补 `platform`。"

#~ msgid ""
#~ "Create the patch file in the right"
#~ " folder. The file should be named "
#~ "as `patch_{module_name}.py`. The example here"
#~ " is "
#~ "`vllm_kunlun/patch/platform/patch_common/patch_distributed.py`."
#~ msgstr ""
#~ "在正确的文件夹中创建补丁文件。文件应命名为 `patch_{module_name}.py`。此处的示例是 "
#~ "`vllm_kunlun/patch/platform/patch_common/patch_distributed.py`。"

#~ msgid "Write your patch code in the new file. Here is an example:"
#~ msgstr "在新文件中编写你的补丁代码。以下是一个示例："

#~ msgid ""
#~ "Import the patch file in `__init__.py`."
#~ " In this example, add `import "
#~ "vllm_kunlun.patch.platform.patch_common.patch_distributed` into"
#~ " `vllm_kunlun/patch/platform/patch_common/__init__.py`."
#~ msgstr ""
#~ "在 `__init__.py` 中导入补丁文件。在这个示例中，将 `import "
#~ "vllm_kunlun.patch.platform.patch_common.patch_distributed` 添加到"
#~ " `vllm_kunlun/patch/platform/patch_common/__init__.py` 中。"

#~ msgid ""
#~ "Add the description of the patch "
#~ "in `vllm_kunlun/patch/__init__.py`. The description"
#~ " format is as follows:"
#~ msgstr "在 `vllm_kunlun/patch/__init__.py` 中添加补丁的描述。描述格式如下："

#~ msgid ""
#~ "Add the Unit Test and E2E Test."
#~ " Any newly added code in vLLM "
#~ "Kunlun should contain the Unit Test "
#~ "and E2E Test as well. You can "
#~ "find more details in [test "
#~ "guide](../contribution/testing.md)"
#~ msgstr ""
#~ "添加单元测试和端到端（E2E）测试。在 vLLM Kunlun "
#~ "中新增的任何代码也应包含单元测试和端到端测试。更多详情请参见 "
#~ "[测试指南](../contribution/testing.md)。"

#~ msgid "Limitation"
#~ msgstr "限制"

#~ msgid ""
#~ "In V1 Engine, vLLM starts three "
#~ "kinds of process: Main process, "
#~ "EngineCore process and Worker process. "
#~ "Now vLLM Kunlun only support patch "
#~ "the code in Main process and "
#~ "Worker process by default. If you "
#~ "want to patch the code runs in "
#~ "EngineCore process, you should patch "
#~ "EngineCore process entirely during setup, "
#~ "the entry code is here "
#~ "`vllm.v1.engine.core`. Please override "
#~ "`EngineCoreProc` and `DPEngineCoreProc` entirely."
#~ msgstr ""
#~ "在 V1 引擎中，vLLM 会启动三种类型的进程：主进程、EngineCore 进程和"
#~ " Worker 进程。现在 vLLM Kunlun 默认只支持在主进程和 "
#~ "Worker 进程中打补丁代码。如果你想要在 EngineCore 进程中打补丁，你需要在设置阶段对"
#~ " EngineCore 进程整体打补丁，入口代码在 `vllm.v1.engine.core`。请完全重写"
#~ " `EngineCoreProc` 和 `DPEngineCoreProc`。"

#~ msgid ""
#~ "If you are running an edited vLLM"
#~ " code, the version of the vLLM "
#~ "may be changed automatically. For "
#~ "example, if you runs an edited "
#~ "vLLM based on v0.9.n, the version "
#~ "of vLLM may be change to "
#~ "v0.9.nxxx, in this case, the patch "
#~ "for v0.9.n in vLLM Kunlun would "
#~ "not work as expect, because that "
#~ "vLLM Kunlun can't distinguish the "
#~ "version of vLLM you're using. In "
#~ "this case, you can set the "
#~ "environment variable `VLLM_VERSION` to specify"
#~ " the version of vLLM you're using,"
#~ " then the patch for v0.9.2 should "
#~ "work."
#~ msgstr ""
#~ "如果你运行的是经过编辑的 vLLM 代码，vLLM 的版本可能会被自动更改。例如，如果你基于 "
#~ "v0.9.n 运行了编辑后的 vLLM，vLLM 的版本可能会变为 "
#~ "v0.9.nxxx，在这种情况下，vLLM Kunlun 的 v0.9.n "
#~ "补丁将无法正常工作，因为 vLLM Kunlun 无法区分你所使用的 vLLM "
#~ "版本。这时，你可以设置环境变量 `VLLM_VERSION` 来指定你所使用的 vLLM "
#~ "版本，这样对 v0.9.2 的补丁就应该可以正常工作。"

